---
title: "Data Management With R: Tidy Data"
author: "Matthias Haber"
date: "09 October 2017"
output:
  beamer_presentation:
    theme: "metropolis"
    colortheme: "default"
    fonttheme: "default"
    fig_caption: false
    df_print: default
    toc: false
  ioslides_presentation:
  slidy_presentation: default
  linkcolor: "red"
---
# Prerequisites

## Packages

```{r, message=FALSE, warning=FALSE}
# install.packages("tidyverse")
library(tidyverse)
```

## Data


## Tidy data

You can represent data in multiple ways. Each of the following datasets shows the same values of four variables *country*, *year*, *population*, and *cases*, but each dataset organises the values in a different way:

```{r}
table1
table2
table3

# Spread across two tibbles
table4a  # cases
table4b  # population
```

## Tidy data

```{r}
table1
```

## Tidy data

```{r}
table2
```

## Tidy data

```{r}
table3
```

## Tidy data

```{r}
table4a  # cases
```

## Tidy data
```{r}
table4b  # population
```

## Tidy data

- In tidy data:

    + Each variable forms a column
    + Each observation forms a row
    + Each type of observational unit forms a table

- Any dataset that doesn't satisfy these conditions is considered 'messy'

## Tidy data

**Not tidy**:

| Person       |  treatmentA | treatmentB |
| ------------ | ----------- | ---------- |
| John Smith   |             | 2          |
| Jane Doe     | 16          | 11         |

**Tidy**:

| Person       |  treatment  | result     |
| ------------ | ----------- | ---------- |
| John Smith   | a           |            |
| Jane Doe     | a           | 16         |
| John Smith   | b           | 2          |
| Jane Doe     | b           | 11         |

## Tidy data

Why data should be tidy:

1.  If you have a consistent data structure, it's easier to learn the tools that work with it because they have an underlying uniformity.
    
2.  R is a vectorized programming language. Data structures in R are built from vectors and Râ€™s operations are optimized to work with vectors. Tidy data takes advantage of both of these traits.

3. dplyr, ggplot2, and all the other packages in the tidyverse are designed to work with tidy data.

## Tidy data

Assume that in these data sets, cases refers to the number of people diagnosed with TB per country per year. To calculate the rate of TB cases per country per year (i.e, the number of people per 10,000 diagnosed with TB), you will need to do four operations with the data. You will need to:

* Extract the number of TB cases per country per year

* Extract the population per country per year (in the same order as above)

* Divide cases by population

* Multiply by 10000

## Tidy data

```{r, out.width = "50%"}
# Compute rate per 10,000
table1 %>% 
  mutate(rate = cases / population * 10000)

# Compute cases per year
table1 %>% 
  count(year, wt = cases)
```


## Exercises

Raw data is rarely tidy and is much harder to work with as a result

1.  Compute the `rate` for `table2`, and `table4a` + `table4b`. 
    You will need to perform four operations:

    1.  Extract the number of TB cases per country per year.
    1.  Extract the matching population per country per year.
    1.  Divide cases by population, and multiply by 10000.
    1.  Store back in the appropriate place.
    
    Which representation is easiest to work with? Which is hardest? Why?

2.  Recreate the plot showing change in cases over time using `table2`
    instead of `table1`. What do you need to do first?

## Exercises solutions

# gathering and spreading

## `gather()` and `spread()` 

The two most important functions in `tidyr` are `gather()` and `spread()`. `tidyr` builds on the idea of a key value pair. A key that explains what the information describes, and a value that contains the actual information.

Password: 0123456789 

`gather()` makes wide tables narrower and longer; `spread()` makes long tables shorter and wider.

##`spread()`

`spread()` turns a pair of key:value columns into a set of tidy columns. 


## `gather()`
A common problem is a dataset where some of the column names are not names of variables, but _values_ of a variable. Take `table4a`: the column names `1999` and `2000` represent values of the `year` variable, and each row represents two observations, not one.

```{r}
table4a
```

To tidy a dataset like this, we need to __gather__ those columns into a new pair of variables. To describe that operation we need three parameters:

* The set of columns that represent values, not variables. In this example, those are the columns `1999` and `2000`.

* The name of the variable whose values form the column names. I call that the `key`, and here it is `year`.

* The name of the variable whose values are spread over the cells. I call that `value`, and here it's the number of `cases`.

## `gather()`

```{r}
table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")
```

The columns to gather are specified with `dplyr::select()` style notation. Here there are only two columns, so we list them individually. Note that "1999" and "2000" are non-syntactic names (because they don't start with a letter) so we have to surround them in backticks. 

## `gather()`

We can use `gather()` to tidy `table4b` in a similar fashion. The only difference is the variable stored in the cell values:

```{r}
table4b %>% 
  gather(`1999`, `2000`, key = "year", value = "population")
```

## `spread()`

Spreading is the opposite of gathering. You use it when an observation is scattered across multiple rows. For example, take `table2`: an observation is a country in a year, but each observation is spread across two rows.

```{r}
table2
```

## `spread()`
To tidy this up, we first analyse the representation in similar way to `gather()`. This time, however, we only need two parameters:

* The column that contains variable names, the `key` column. Here, it's 
  `type`.

* The column that contains values forms multiple variables, the `value`
  column. Here it's `count`.

Once we've figured that out, we can use `spread()`, as shown programmatically below, and visually in Figure \@ref(fig:tidy-spread).

```{r}
spread(table2, key = type, value = count)
```

## Exercises

1.  Why does this code fail?

    ```{r, error = TRUE}
    table4a %>% 
      gather(1999, 2000, key = "year", value = "cases")
    ```

2.  Tidy the simple tibble below. Do you need to spread or gather it?


    ```{r}
    preg <- tribble(
      ~pregnant, ~male, ~female,
      "yes",     NA,    10,
      "no",      20,    12
    )
    ```

3. Read in the `weather` data from GitHub:
 Tidy the day columns X1-X31 and save the result as weather2.
 
4. Spread the measure column of weather2.
 
## Exercises solutions

# Separating and uniting

##  `separate()`

`separate()` pulls apart one column into multiple columns, by splitting wherever a separator character appears. Take `table3`:

```{r}
table3
```

The `rate` column contains both `cases` and `population` variables, and we need to split it into two variables. `separate()` takes the name of the column to separate, and the names of the columns to separate into, as shown in Figure \@ref(fig:tidy-separate) and the code below.

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"))
```

## `separate()`

By default, `separate()` will split values wherever it sees a non-alphanumeric character (i.e. a character that isn't a number or letter). For example, in the code above, `separate()` split the values of `rate` at the forward slash characters. If you wish to use a specific character to separate a column, you can pass the character to the `sep` argument of `separate()`. For example, we could rewrite the code above as:

```{r eval = FALSE}
table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/")
```

## `separate()`

You can also pass a vector of integers to `sep`. `separate()` will interpret the integers as positions to split at. Positive values start at 1 on the far-left of the strings; negative value start at -1 on the far-right of the strings. When using integers to separate strings, the length of `sep` should be one less than the number of names in `into`. 

You can use this arrangement to separate the last two digits of each year. This make this data less tidy, but is useful in other cases, as you'll see in a little bit.

```{r}
table3 %>% 
  separate(year, into = c("century", "year"), sep = 2)
```

## `unite()`

`unite()` is the inverse of `separate()`: it combines multiple columns into a single column. You'll need it much less frequently than `separate()`, but it's still a useful tool to have in your back pocket.

We can use `unite()` to rejoin the *century* and *year* columns that we created in the last example. That data is saved as `tidyr::table5`. `unite()` takes a data frame, the name of the new variable to create, and a set of columns to combine, again specified in `dplyr::select()` style:

```{r}
table5 %>% 
  unite(new, century, year)
```

## `unite()`

In this case we also need to use the `sep` argument. The default will place an underscore (`_`) between the values from different columns. Here we don't want any separator so we use `""`:

```{r}
table5 %>% 
  unite(new, century, year, sep = "")
```

# Missing values

## Missing values

Changing the representation of a dataset brings up an important subtlety of missing values. Surprisingly, a value can be missing in one of two possible ways:

* __Explicitly__, i.e. flagged with `NA`.
* __Implicitly__, i.e. simply not present in the data.

Let's illustrate this idea with a very simple data set:

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr    = c(   1,    2,    3,    4,    2,    3,    4),
  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```

There are two missing values in this dataset:

* The return for the fourth quarter of 2015 is explicitly missing, because
  the cell where its value should be instead contains `NA`.
  
* The return for the first quarter of 2016 is implicitly missing, because it
  simply does not appear in the dataset.
  
One way to think about the difference is with this Zen-like koan: An explicit missing value is the presence of an absence; an implicit missing value is the absence of a presence.

The way that a dataset is represented can make implicit values explicit. For example, we can make the implicit missing value explicit by putting years in the columns:

```{r}
stocks %>% 
  spread(year, return)
```

Because these explicit missing values may not be important in other representations of the data, you can set `na.rm = TRUE` in `gather()` to turn explicit missing values implicit:

```{r}
stocks %>% 
  spread(year, return) %>% 
  gather(year, return, `2015`:`2016`, na.rm = TRUE)
```

Another important tool for making missing values explicit in tidy data is `complete()`:

```{r}
stocks %>% 
  complete(year, qtr)
```

`complete()` takes a set of columns, and finds all unique combinations. It then ensures the original dataset contains all those values, filling in explicit `NA`s where necessary.

There's one other important tool that you should know for working with missing values. Sometimes when a data source has primarily been used for data entry, missing values indicate that the previous value should be carried forward:

```{r}
treatment <- tribble(
  ~ person,           ~ treatment, ~response,
  "Derrick Whitmore", 1,           7,
  NA,                 2,           10,
  NA,                 3,           9,
  "Katherine Burke",  1,           4
)
```

You can fill in these missing values with `fill()`. It takes a set of columns where you want missing values to be replaced by the most recent non-missing value (sometimes called last observation carried forward).

```{r}
treatment %>% 
  fill(person)
```


# Homework Exercises

## Homework Exercises
For this week's homework exersises go to Moodle and answer the Quiz posted in the Tidy Data section. You will be asked a number of questions randomly selected from a question pool. If you work in pairs, then you might get two different sets of questions. 

Deadline: Sunday, September 24 before midnight.


##  {.standout}
That's it for today. Questions?    

